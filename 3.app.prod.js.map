{"version":3,"sources":["webpack:///./src/media/compose.ts","webpack:///./src/media/middleware/base.ts","webpack:///./src/utils/http.ts","webpack:///./src/media/middleware/subreddit.ts","webpack:///./src/media/middleware/youtube.ts","webpack:///./src/media/middleware/youtube-playlist.ts","webpack:///./src/media/middleware/httpHead.ts","webpack:///./src/media/middleware/media.ts","webpack:///./src/media/middleware/html.ts","webpack:///./src/media/middleware/og.js","webpack:///./src/media/middleware/openGraph.ts","webpack:///./src/media/middleware/oembed.ts","webpack:///./src/media/middleware/autoplay.ts","webpack:///./src/media/middleware/microdata.ts","webpack:///./src/media/middleware/imgur.ts","webpack:///./src/media/error.ts","webpack:///./src/media/middleware/preventDownload.ts","webpack:///./src/media/index.ts"],"names":["media_compose","middleware","Array","isArray","TypeError","mware","match","resolve","ctx","index","dispatch","i","Promise","reject","Error","req","url","err","base","origin","location","[object Object]","next","transformList","Set","prefixHeaders","headers","Object","keys","forEach","name","has","toLowerCase","fetchId","mainFetch","options","startsWith","URL","e","credentials","requestId","handler","event","data","type","window","removeEventListener","resp","payload","addEventListener","extension","fetchText","async","body","URL_PATTERN","transformPost","result","id","title","subreddit","xpost","crosspost_parent_list","media","length","parent","getListing","after","urlobj","url_url","paramObj","query","limit","params","utils_url","apiUrl","protocol","hostname","pathname","json","Referer","http","getNextPosts","children","filter","post","stickied","map","isSubreddit","exec","href","isCommentThread","includes","state","reddit","reqState","redditUrl","currentIdx","idx","console","log","error","debug","posts","child","res","hasMore","item","reddit_video","v","duration","oembed","parseItem","youtube_URL_PATTERN","VIDEO_ID_PATTERNS","YouTubeClient","this","instance","youtube","getInstance","getVideoId","metadata","$","isoDuration","attr","metaBroadcast","metaBroadcastEndDate","utils","undefined","metaDescription","description","searchParams","getScrapedMetadata","message","referrer","oEmbed","youtube_playlist_URL_PATTERN","youtube_playlist","isYouTube","isPlaylist","Boolean","ytpl","text","trim","rawLen","split","len","parseInt","isNaN","embedUrl","delete","rawIndex","get","set","toString","httpHead","response","fetchResponse","method","user-agent","referer","httpHeadFailed","code","status","server","contentType","val","shift","getContentTypeToken","getTypeToken","responseCode","disableGooglebot","MIME_MEDIA_TYPES","middleware_media","meta","path_browserify","buildMediaMetadata","sortIcons","a","b","aIco","attribs","bIco","middleware_html","host","cheerio","parseTitle","favicon","icons","from","icon","rel","sort","parseFavicon","fieldsArray","multiple","property","fieldName","mediaMapperTwitterImage","width","height","alt","mediaMapperTwitterPlayer","stream","mediaMapper","str","parseFloat","mediaSorter","aRes","aExt","bRes","bExt","Math","max","BAD_VIDEO_TYPES","IGNORE_VIDEO_HOSTNAMES","buildHTMLMetadata","og","ogImageFallback","ogObject","key","content","push","ogImage","ogImageSecureURL","ogImageURL","ogImageWidth","twitterImageHeight","ogImageType","ogImageHeight","ogImages","zip","ogVideo","ogVideoWidth","ogVideoHeight","ogVideoType","ogVideoDuration","ogVideoSecureURL","videoDuration","ogVideos","twitterImageSrc","twitterImage","twitterImageWidth","twitterImageAlt","twitterImages","twitterPlayer","twitterPlayerWidth","twitterPlayerHeight","twitterPlayerStream","twitterPlayers","allMedia","onlyGetOpenGraphInfo","ogTitle","ogDescription","supportedImageExts","each","elem","indexOf","pop","parse","image","thumbnails","0","useVideo","videoUrl","openGraph","WORDPRESS_OEMBED_PATH","oEmbedJson","link","test","fetchOEmbed","info","html","src","parseOembedUrl","setQueryTrue","prop","autoplay","endsWith","urlObj","search","setAutoplay","microdata","metaDuration","lib","imgur","imageSrc","MediaRequestError","super","setPrototypeOf","prototype","preventDownload","headResponseHeaders","contentDisp","__webpack_require__","d","__webpack_exports__","resolveMediaUrl","resolveMediaPlaylist","middlewares","createContext","user","finalizeMedia","desc","object","fn"],"mappings":"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","file":"3.app.prod.js","sourcesContent":["/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\nfunction compose(middleware) {\n    if (!Array.isArray(middleware))\n        throw new TypeError('Middleware stack must be an array!');\n    for (const mware of middleware) {\n        if (typeof mware.match !== 'function' || typeof mware.resolve !== 'function') {\n            throw new TypeError('Middleware must be composed of functions!');\n        }\n    }\n    /**\n     * @param {Object} context\n     * @return {Promise}\n     * @api public\n     */\n    return function (ctx) {\n        // last called middleware #\n        let index = -1;\n        return dispatch(0);\n        function dispatch(i) {\n            if (i <= index)\n                return Promise.reject(new Error('next() called multiple times'));\n            index = i;\n            let mware = middleware[i];\n            if (!mware)\n                return Promise.resolve();\n            if (!mware.match(ctx.req.url, ctx)) {\n                return Promise.resolve(dispatch(i + 1));\n            }\n            try {\n                return Promise.resolve(mware.resolve(ctx, function next() {\n                    return dispatch(i + 1);\n                }));\n            }\n            catch (err) {\n                return Promise.reject(err);\n            }\n        }\n    };\n}\nexport default compose;\n","const mware = {\n    match({ origin }) {\n        return origin === location.origin;\n    },\n    resolve(ctx, next) {\n        throw new Error('Unable to request Metastream app link');\n    }\n};\nexport default mware;\n","import { dispatchExtensionMessage } from './extension';\nconst transformList = new Set(['user-agent', 'referer']);\nconst prefixHeaders = (headers) => {\n    if (typeof headers === 'object') {\n        headers = { ...headers };\n        // Prefix reserved headers to be fixed in the extension background script\n        Object.keys(headers).forEach(name => {\n            if (transformList.has(name.toLowerCase())) {\n                headers[`X-Metastream-${name}`] = headers[name];\n            }\n        });\n    }\n    return headers;\n};\nlet fetchId = 0;\nconst mainFetch = (url, options = {}) => {\n    return new Promise((resolve, reject) => {\n        if (url.startsWith('//')) {\n            url = `https:${url}`;\n        }\n        try {\n            new URL(url);\n        }\n        catch (e) {\n            reject(e);\n            return;\n        }\n        options = {\n            credentials: 'omit',\n            ...options,\n            headers: prefixHeaders(options.headers)\n        };\n        const requestId = fetchId++;\n        const handler = (event) => {\n            const { data } = event;\n            if (typeof data !== 'object')\n                return;\n            if (data.type !== `metastream-fetch-response${requestId}`)\n                return;\n            window.removeEventListener('message', handler, false);\n            const { err, resp } = data.payload;\n            if (err) {\n                reject(err);\n                return;\n            }\n            resolve(resp);\n        };\n        window.addEventListener('message', handler, false);\n        dispatchExtensionMessage('metastream-fetch', { requestId, url, options });\n    });\n};\nexport const fetchText = async (url, options) => {\n    const resp = await mainFetch(url, options);\n    return [resp.body, resp];\n};\nexport const fetchResponse = async (url, options) => {\n    const resp = await mainFetch(url, options);\n    return resp;\n};\n","import { parse } from 'url';\nimport { encodeQueryParams } from 'utils/url';\nimport { fetchText } from 'utils/http';\nimport { MEDIA_REFERRER } from 'constants/http';\nconst URL_PATTERN = /reddit\\.com\\/r\\/([^\\s/]+)\\/?/i;\nconst API_LIMIT = 5;\nconst transformPost = ({ data }) => {\n    let result = {\n        id: data.id,\n        url: data.url,\n        title: `${data.title} - /r/${data.subreddit}`\n    };\n    const xpost = data.crosspost_parent_list;\n    // TODO: secure_media_embed\n    if (data.media) {\n        result.media = data.media;\n    }\n    if (xpost && xpost.length > 0) {\n        const parent = xpost[0];\n        if (parent.url) {\n            result.url = parent.url;\n        }\n        if (parent.media) {\n            result.media = parent.media;\n        }\n    }\n    return result;\n};\nconst getListing = async (url, after) => {\n    const urlobj = parse(url, true);\n    const paramObj = {\n        ...urlobj.query,\n        limit: API_LIMIT\n    };\n    if (after) {\n        paramObj.after = after;\n    }\n    const params = encodeQueryParams(paramObj);\n    // TODO: Keep GET params for filtering\n    // TODO: Pick up from previous playlist state\n    const apiUrl = `${urlobj.protocol}//${urlobj.hostname}${urlobj.pathname}.json?${params}`;\n    const [json] = await fetchText(apiUrl, {\n        headers: {\n            Referer: MEDIA_REFERRER\n        }\n    });\n    return json;\n};\nconst getNextPosts = (json) => {\n    const posts = json.data.children.filter(post => !post.data.stickied).map(transformPost);\n    return posts;\n};\nconst parseItem = (ctx, item) => {\n    ctx.res.title = item.title;\n    // Overwrite request url with subreddit post\n    const url = new URL(item.url);\n    if (url && url.href) {\n        ctx.req.url = url;\n    }\n    const { media } = item;\n    if (media) {\n        if (media.reddit_video) {\n            const v = media.reddit_video;\n            if (url && url.href)\n                ctx.res.url = url.href;\n            const duration = v.duration * 1000;\n            if (duration)\n                ctx.res.duration = duration;\n            return true;\n        }\n        else if (media.oembed) {\n            // Defer parse to oembed middleware\n            // ctx.state.oEmbedJson = media.oembed\n            return false;\n        }\n    }\n    return false;\n};\nconst mware = {\n    match(url, ctx) {\n        const isSubreddit = !!URL_PATTERN.exec(url.href);\n        const isCommentThread = url.pathname ? url.pathname.includes('/comments/') : false;\n        return (isSubreddit && !isCommentThread) || !!(ctx.req.state && ctx.req.state.reddit);\n    },\n    async resolve(ctx, next) {\n        const reqState = ctx.req.state;\n        let redditUrl;\n        let children;\n        let after;\n        let currentIdx;\n        // TODO: filter for API listings (/hot, /new, etc.)\n        // https://www.reddit.com/dev/api/#section_listings\n        if (reqState && reqState.reddit) {\n            redditUrl = reqState.reddit.href;\n            children = reqState.reddit.children;\n            after = reqState.reddit.after;\n            currentIdx = reqState.reddit.idx;\n        }\n        else {\n            redditUrl = ctx.req.url.href;\n            const json = await getListing(redditUrl);\n            console.log('Subreddit JSON', json);\n            if (json.error) {\n                console.debug('Error fetching subreddit posts');\n                return next();\n            }\n            const posts = getNextPosts(json);\n            if (posts.length === 0) {\n                return next();\n            }\n            children = posts;\n            after = json.data.after;\n            currentIdx = -1;\n        }\n        let idx = currentIdx + 1;\n        let child = children[idx];\n        if (!child) {\n            const json = await getListing(reqState.reddit.href, reqState.reddit.after);\n            const posts = getNextPosts(json);\n            if (posts.length === 0) {\n                return next();\n            }\n            idx = 0;\n            children = posts;\n            child = children[idx];\n            after = json.data.after;\n            if (!child) {\n                return;\n            }\n        }\n        // Save pagination info for resolving next playlist item\n        ctx.res.type = \"playlist\" /* Playlist */;\n        ctx.res.hasMore = true;\n        ctx.res.state = {\n            ...ctx.res.state,\n            reddit: {\n                ...(reqState || {}).reddit,\n                href: redditUrl,\n                idx,\n                children,\n                after\n            }\n        };\n        if (!parseItem(ctx, child)) {\n            await next();\n            let title = child.title || ctx.res.title;\n            ctx.res.title = title;\n            return ctx.res;\n        }\n    }\n};\nexport default mware;\n","import { mergeMetadata, parseHtmlDescription, parseISO8601 } from '../utils';\nconst URL_PATTERN = /youtu\\.?be(?:.com)?/i;\n// TODO: https://www.youtube.com/attribution_link?a=ShEHdkiTDq4&u=%2Fwatch%3Fv%3Dm-6zjXLPRHg%26feature%3Dshare\nconst VIDEO_ID_PATTERNS = [\n    /youtu\\.be\\/([^#\\&\\?]{11})/,\n    /\\?v=([^#\\&\\?]{11})/,\n    /\\&v=([^#\\&\\?]{11})/,\n    /embed\\/([^#\\&\\?]{11})/,\n    /\\/v\\/([^#\\&\\?]{11})/ // /v/<id>\n];\nclass YouTubeClient {\n    static getInstance() {\n        if (!this.instance) {\n            this.instance = new YouTubeClient();\n        }\n        return this.instance;\n    }\n    getVideoId(url) {\n        let match;\n        for (let i = 0; i < VIDEO_ID_PATTERNS.length; i++) {\n            match = VIDEO_ID_PATTERNS[i].exec(url);\n            if (match) {\n                break;\n            }\n        }\n        return match ? match[1] : null;\n    }\n}\nasync function getScrapedMetadata(url, $) {\n    const metaDuration = $('meta[itemprop=duration]');\n    const isoDuration = metaDuration.attr('content');\n    const metaBroadcast = $('meta[itemprop=isLiveBroadcast]');\n    const metaBroadcastEndDate = $('meta[itemprop=endDate]');\n    const isLiveBroadcast = (metaBroadcast.attr('content') || '').toLowerCase() === 'true' && !metaBroadcastEndDate;\n    let duration;\n    if (isLiveBroadcast) {\n        duration = 0;\n    }\n    else {\n        duration = isoDuration ? parseISO8601(isoDuration) * 1000 : undefined;\n    }\n    const metaDescription = $('#eow-description');\n    const description = metaDescription.length === 1 ? parseHtmlDescription(metaDescription) : undefined;\n    if (url.searchParams.has('t')) {\n        // TODO: parse '1h2m3s' format\n        // startTime = parseHms(query.t)\n    }\n    return {\n        duration,\n        description\n    };\n}\nconst mware = {\n    match(url) {\n        const { hostname = '', href = '' } = url;\n        return !!URL_PATTERN.exec(hostname) && !!YouTubeClient.getInstance().getVideoId(href);\n    },\n    async resolve(ctx, next) {\n        let metadata;\n        try {\n            metadata = await getScrapedMetadata(ctx.req.url, ctx.state.$);\n        }\n        catch (e) {\n            console.error('YouTube request failed', e.message);\n            return next();\n        }\n        mergeMetadata(ctx.res, metadata);\n        // Bypass restricted embed playback\n        ctx.res.state.referrer = true;\n        // Disable oEmbed for playlists\n        ctx.state.oEmbed = false;\n        return next();\n    }\n};\nexport default mware;\n","const URL_PATTERN = /youtu\\.?be(?:.com)?/i;\nconst mware = {\n    match(url, ctx) {\n        const isYouTube = !!URL_PATTERN.exec(url.href);\n        const isPlaylist = url.searchParams.has('list');\n        return (isYouTube && isPlaylist) || Boolean(ctx.req.state && ctx.req.state.ytpl);\n    },\n    async resolve(ctx, next) {\n        const { state } = ctx.req;\n        const ytpl = (state && state.ytpl) || {};\n        const isInitialRequest = typeof ytpl.index === 'undefined';\n        if (isInitialRequest) {\n            await next();\n            const { res } = ctx;\n            const { body, $ } = ctx.state;\n            if (!body || !$)\n                return;\n            const title = $('.playlist-title').text() || res.title;\n            ytpl.title = (title || 'YouTube Playlist').trim();\n            const rawLen = $('#playlist-length')\n                .text()\n                .split(' ')[0];\n            const len = parseInt(rawLen, 10);\n            if (isNaN(len)) {\n                // private playlist\n                // try to remove playlist params from embed\n                try {\n                    const embedUrl = new URL(ctx.res.url);\n                    embedUrl.searchParams.delete('list');\n                    ctx.res.url = embedUrl.href;\n                }\n                catch { }\n                return ctx.res;\n            }\n            ytpl.length = len;\n            const rawIndex = $('li.currently-playing').data('index');\n            const params = ctx.req.url.searchParams;\n            const index = rawIndex || params.get('index') || '0';\n            ytpl.index = parseInt(index, 10) || 0;\n            ctx.res.state.ytpl = ytpl;\n        }\n        else {\n            ytpl.index++;\n            const url = ctx.req.url;\n            url.pathname = '/embed/videoseries';\n            url.searchParams.set('index', `${ytpl.index}`);\n            ctx.res.url = url.toString();\n        }\n        let { index, length, title } = ytpl;\n        ctx.res.title = title;\n        ctx.res.state = { ...ctx.req.state, ytpl, referrer: true };\n        ctx.res.hasMore = index < length - 1;\n        return ctx.res;\n    }\n};\nexport default mware;\n","import { fetchResponse } from 'utils/http';\nimport { MEDIA_USER_AGENT } from 'constants/http';\nconst getContentTypeToken = (val) => {\n    val = Array.isArray(val) ? val[0] : val;\n    val = (val && val.split(';').shift()) || '';\n    return val.trim();\n};\n/** https://www.w3.org/Protocols/rfc1341/4_Content-Type.html */\nconst getTypeToken = (val) => (val ? (val.split('/').shift() || '').toLowerCase() : '');\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { url } = ctx.req;\n        // Request HEAD response to check MIME type\n        let response;\n        try {\n            response = await fetchResponse(url.href, {\n                method: 'HEAD',\n                headers: {\n                    'user-agent': MEDIA_USER_AGENT,\n                    referer: url.href // prevent hotlink blocking\n                }\n            });\n        }\n        catch {\n            ctx.state.httpHeadFailed = true;\n            return next();\n        }\n        const code = response.status || 200;\n        const server = response.headers['server'];\n        const contentType = getContentTypeToken(response.headers['content-type']);\n        const type = getTypeToken(contentType);\n        ctx.state.responseCode = code;\n        ctx.state.contentType = contentType;\n        ctx.state.type = type;\n        // #244: Cloudflare validates agents using the Googlebot UA\n        ctx.state.disableGooglebot = server === 'cloudflare';\n        return next();\n    }\n};\nexport default mware;\n","import { basename } from 'path';\nconst MIME_MEDIA_TYPES = new Set(['audio', 'image', 'video']);\nfunction buildMediaMetadata(url) {\n    // TODO: get ID3 metadata from MP3s\n    return {\n        url: url.href,\n        title: basename(url.pathname || url.href)\n    };\n}\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    resolve({ req, res, state }, next) {\n        const { url } = req;\n        const { type } = state;\n        // Avoid GET requests to media\n        if (type && MIME_MEDIA_TYPES.has(type)) {\n            const meta = buildMediaMetadata(url);\n            res.url = meta.url || res.url;\n            res.title = res.title || meta.title;\n            return res;\n        }\n        return next();\n    }\n};\nexport default mware;\n","import { load } from 'cheerio';\nimport { fetchText } from 'utils/http';\nimport { MEDIA_USER_AGENT } from 'constants/http';\nconst parseTitle = ($) => $('title')\n    .text()\n    .trim();\n/** Prefer non-ico icons. */\nconst sortIcons = (a, b) => {\n    const aIco = a.attribs.href.includes('.ico');\n    const bIco = b.attribs.href.includes('.ico');\n    if (aIco && !bIco)\n        return 1;\n    if (!aIco && bIco)\n        return -1;\n    return 0;\n};\nconst parseFavicon = (ctx, $) => {\n    const icons = Array.from($('head link')).filter(icon => {\n        const rel = new Set((icon.attribs.rel || '').split(' '));\n        if (!rel.has('icon'))\n            return false;\n        return true;\n    });\n    if (icons.length === 0)\n        return;\n    icons.sort(sortIcons);\n    const icon = icons[0];\n    let url;\n    try {\n        url = new URL(icon.attribs.href).href;\n    }\n    catch { }\n    if (!url) {\n        try {\n            url = new URL(`${ctx.req.url.origin}${icon.attribs.href}`).href;\n        }\n        catch { }\n    }\n    return url;\n};\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { url } = ctx.req;\n        // Skip if HEAD request fails to avoid fetching huge blobs of data\n        if (ctx.state.httpHeadFailed) {\n            return next();\n        }\n        let text;\n        try {\n            const result = await fetchText(url.href, {\n                headers: ctx.state.disableGooglebot\n                    ? {}\n                    : {\n                        'user-agent': MEDIA_USER_AGENT,\n                        host: url.host\n                    }\n            });\n            text = result[0];\n        }\n        catch {\n            return next();\n        }\n        ctx.state.body = text;\n        const $ = (ctx.state.$ = load(text));\n        try {\n            ctx.res.title = parseTitle($) || ctx.res.title;\n            ctx.res.favicon = parseFavicon(ctx, $);\n        }\n        catch (e) {\n            console.error(e);\n        }\n        return next();\n    }\n};\nexport default mware;\n","import { load } from 'cheerio'\nimport { zip } from 'lodash-es'\n\nconst fieldsArray = [\n  {\n    multiple: false,\n    property: 'og:title',\n    fieldName: 'ogTitle'\n  },\n  {\n    multiple: false,\n    property: 'og:type',\n    fieldName: 'ogType'\n  },\n  {\n    multiple: true,\n    property: 'og:image',\n    fieldName: 'ogImage'\n  },\n  {\n    multiple: true,\n    property: 'og:image:url',\n    fieldName: 'ogImageURL'\n  },\n  {\n    multiple: true,\n    property: 'og:image:secure_url',\n    fieldName: 'ogImageSecureURL'\n  },\n  {\n    multiple: true,\n    property: 'og:image:width',\n    fieldName: 'ogImageWidth'\n  },\n  {\n    multiple: true,\n    property: 'og:image:height',\n    fieldName: 'ogImageHeight'\n  },\n  {\n    multiple: true,\n    property: 'og:image:type',\n    fieldName: 'ogImageType'\n  },\n  {\n    multiple: false,\n    property: 'og:url',\n    fieldName: 'ogUrl'\n  },\n  {\n    multiple: false,\n    property: 'og:audio',\n    fieldName: 'ogAudio'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:url',\n    fieldName: 'ogAudioURL'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:secure_url',\n    fieldName: 'ogAudioSecureURL'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:type',\n    fieldName: 'ogAudioType'\n  },\n  {\n    multiple: false,\n    property: 'og:description',\n    fieldName: 'ogDescription'\n  },\n  {\n    multiple: false,\n    property: 'og:determiner',\n    fieldName: 'ogDeterminer'\n  },\n  {\n    multiple: false,\n    property: 'og:locale',\n    fieldName: 'ogLocale'\n  },\n  {\n    multiple: false,\n    property: 'og:locale:alternate',\n    fieldName: 'ogLocaleAlternate'\n  },\n  {\n    multiple: false,\n    property: 'og:site_name',\n    fieldName: 'ogSiteName'\n  },\n  {\n    multiple: true,\n    property: 'og:video',\n    fieldName: 'ogVideo'\n  },\n  {\n    multiple: true,\n    property: 'og:video:url', // An alternative to 'og:video'\n    fieldName: 'ogVideo'\n  },\n  {\n    multiple: true,\n    property: 'og:video:secure_url',\n    fieldName: 'ogVideoSecureURL'\n  },\n  {\n    multiple: true,\n    property: 'og:video:width',\n    fieldName: 'ogVideoWidth'\n  },\n  {\n    multiple: true,\n    property: 'og:video:height',\n    fieldName: 'ogVideoHeight'\n  },\n  {\n    multiple: true,\n    property: 'og:video:type',\n    fieldName: 'ogVideoType'\n  },\n  // This format is wrong, but was seen on vk.com\n  {\n    multiple: true,\n    property: 'og:video:duration',\n    fieldName: 'ogVideoDuration'\n  },\n  {\n    multiple: true,\n    property: 'video:duration',\n    fieldName: 'videoDuration'\n  },\n  {\n    multiple: false,\n    property: 'twitter:card',\n    fieldName: 'twitterCard'\n  },\n  {\n    multiple: false,\n    property: 'twitter:site',\n    fieldName: 'twitterSite'\n  },\n  {\n    multiple: false,\n    property: 'twitter:site:id',\n    fieldName: 'twitterSiteId'\n  },\n  {\n    multiple: false,\n    property: 'twitter:creator',\n    fieldName: 'twitterCreator'\n  },\n  {\n    multiple: false,\n    property: 'twitter:creator:id',\n    fieldName: 'twitterCreatorId'\n  },\n  {\n    multiple: false,\n    property: 'twitter:title',\n    fieldName: 'twitterTitle'\n  },\n  {\n    multiple: false,\n    property: 'twitter:description',\n    fieldName: 'twitterDescription'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image',\n    fieldName: 'twitterImage'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:height',\n    fieldName: 'twitterImageHeight'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:width',\n    fieldName: 'twitterImageWidth'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:src',\n    fieldName: 'twitterImageSrc'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:alt',\n    fieldName: 'twitterImageAlt'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player',\n    fieldName: 'twitterPlayer'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:width',\n    fieldName: 'twitterPlayerWidth'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:height',\n    fieldName: 'twitterPlayerHeight'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:stream',\n    fieldName: 'twitterPlayerStream'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:iphone',\n    fieldName: 'twitterAppNameiPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:iphone',\n    fieldName: 'twitterAppIdiPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:iphone',\n    fieldName: 'twitterAppUrliPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:ipad',\n    fieldName: 'twitterAppNameiPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:ipad',\n    fieldName: 'twitterAppIdiPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:ipad',\n    fieldName: 'twitterAppUrliPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:googleplay',\n    fieldName: 'twitterAppNameGooglePlay'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:googleplay',\n    fieldName: 'twitterAppIdGooglePlay'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:googleplay',\n    fieldName: 'twitterAppUrlGooglePlay'\n  }\n]\n\nvar parseNumbers = function(str) {\n  if (!isNaN(str)) {\n    str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str)\n  }\n  return str\n}\n\nvar mediaMapperTwitterImage = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    alt: item[3]\n  }\n}\n\nvar mediaMapperTwitterPlayer = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    stream: item[3]\n  }\n}\n\nvar mediaMapper = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    type: item[3],\n    duration: parseNumbers(item[4])\n  }\n}\n\nvar mediaSorter = function(a, b) {\n  if (!(a.url && b.url)) {\n    return 0\n  }\n\n  var aRes = a.url.match(/\\.(\\w{2,5})$/),\n    aExt = (aRes && aRes[1].toLowerCase()) || null\n  var bRes = b.url.match(/\\.(\\w{2,5})$/),\n    bExt = (bRes && bRes[1].toLowerCase()) || null\n\n  if (aExt === 'gif' && bExt !== 'gif') {\n    return -1\n  } else if (aExt !== 'gif' && bExt === 'gif') {\n    return 1\n  } else {\n    return Math.max(b.width, b.height) - Math.max(a.width, a.height)\n  }\n}\n\n/*\n * getOG - scrape that url!\n * @param string url - the url we want to scrape\n * @param function callback\n */\nexport function parse(body, options) {\n  const ogImageFallback = options.ogImageFallback === undefined ? true : options.ogImageFallback\n\n  let $ = load(body),\n    meta = $('meta'),\n    keys = Object.keys(meta)\n\n  let ogObject = {}\n\n  keys.forEach(function(key) {\n    if (!(meta[key].attribs && (meta[key].attribs.property || meta[key].attribs.name))) {\n      return\n    }\n    var property = meta[key].attribs.property || meta[key].attribs.name,\n      content = meta[key].attribs.content\n    fieldsArray.forEach(function(item) {\n      if (property === item.property) {\n        if (!item.multiple) {\n          ogObject[item.fieldName] = content\n        } else if (!ogObject[item.fieldName]) {\n          ogObject[item.fieldName] = [content]\n        } else if (Array.isArray(ogObject[item.fieldName])) {\n          ogObject[item.fieldName].push(content)\n        }\n      }\n    })\n  })\n\n  // set the ogImage or fallback to ogImageURL or ogImageSecureURL\n  ogObject.ogImage = ogObject.ogImageSecureURL\n    ? ogObject.ogImageSecureURL\n    : ogObject.ogImage\n    ? ogObject.ogImage\n    : ogObject.ogImageURL\n    ? ogObject.ogImageURL\n    : []\n  if (!ogObject.ogImage || !ogObject.ogImage.length) {\n    delete ogObject['ogImage']\n  }\n\n  /* Combine image/width/height/type\n      and sort for priority */\n  if (\n    ogObject.ogImage ||\n    ogObject.ogImageWidth ||\n    ogObject.twitterImageHeight ||\n    ogObject.ogImageType\n  ) {\n    ogObject.ogImage = ogObject.ogImage ? ogObject.ogImage : [null]\n    ogObject.ogImageWidth = ogObject.ogImageWidth ? ogObject.ogImageWidth : [null]\n    ogObject.ogImageHeight = ogObject.ogImageHeight ? ogObject.ogImageHeight : [null]\n    ogObject.ogImageType = ogObject.ogImageType ? ogObject.ogImageType : [null]\n  }\n  var ogImages = zip(\n    ogObject.ogImage,\n    ogObject.ogImageWidth,\n    ogObject.ogImageHeight,\n    ogObject.ogImageType\n  )\n    .map(mediaMapper)\n    .sort(mediaSorter)\n\n  /* Combine video/width/height/type\n      and sort for priority */\n  if (\n    ogObject.ogVideo ||\n    ogObject.ogVideoWidth ||\n    ogObject.ogVideoHeight ||\n    ogObject.ogVideoType ||\n    ogObject.ogVideoDuration\n  ) {\n    ogObject.ogVideo = ogObject.ogVideo ? ogObject.ogVideo : [null]\n    ogObject.ogVideo = ogObject.ogVideoSecureURL ? ogObject.ogVideoSecureURL : ogObject.ogVideo\n    ogObject.ogVideoWidth = ogObject.ogVideoWidth ? ogObject.ogVideoWidth : [null]\n    ogObject.ogVideoHeight = ogObject.ogVideoHeight ? ogObject.ogVideoHeight : [null]\n    ogObject.ogVideoType = ogObject.ogVideoType ? ogObject.ogVideoType : [null]\n    ogObject.ogVideoDuration = ogObject.videoDuration || ogObject.ogVideoDuration || [null]\n  }\n  var ogVideos = zip(\n    ogObject.ogVideo,\n    ogObject.ogVideoWidth,\n    ogObject.ogVideoHeight,\n    ogObject.ogVideoType,\n    ogObject.ogVideoDuration\n  )\n    .map(mediaMapper)\n    .sort(mediaSorter)\n\n  /* Combine twitter image/width/height/alt\n      and sort for priority */\n  if (\n    ogObject.twitterImageSrc ||\n    ogObject.twitterImage ||\n    ogObject.twitterImageWidth ||\n    ogObject.twitterImageHeight ||\n    ogObject.twitterImageAlt\n  ) {\n    ogObject.twitterImage = ogObject.twitterImage ? ogObject.twitterImage : ogObject.twitterImageSrc\n    ogObject.twitterImage = ogObject.twitterImage ? ogObject.twitterImage : [null]\n    ogObject.twitterImageWidth = ogObject.twitterImageWidth ? ogObject.twitterImageWidth : [null]\n    ogObject.twitterImageHeight = ogObject.twitterImageHeight ? ogObject.twitterImageHeight : [null]\n    ogObject.twitterImageAlt = ogObject.twitterImageAlt ? ogObject.twitterImageAlt : [null]\n  }\n  var twitterImages = zip(\n    ogObject.twitterImage,\n    ogObject.twitterImageWidth,\n    ogObject.twitterImageHeight,\n    ogObject.twitterImageAlt\n  )\n    .map(mediaMapperTwitterImage)\n    .sort(mediaSorter)\n\n  /* Combine twitter player/width/height/stream\n      and sort for priority */\n  if (\n    ogObject.twitterPlayer ||\n    ogObject.twitterPlayerWidth ||\n    ogObject.twitterPlayerHeight ||\n    ogObject.twitterPlayerStream\n  ) {\n    ogObject.twitterPlayer = ogObject.twitterPlayer ? ogObject.twitterPlayer : [null]\n    ogObject.twitterPlayerWidth = ogObject.twitterPlayerWidth ? ogObject.twitterPlayerWidth : [null]\n    ogObject.twitterPlayerHeight = ogObject.twitterPlayerHeight\n      ? ogObject.twitterPlayerHeight\n      : [null]\n    ogObject.twitterPlayerStream = ogObject.twitterPlayerStream\n      ? ogObject.twitterPlayerStream\n      : [null]\n  }\n  var twitterPlayers = zip(\n    ogObject.twitterPlayer,\n    ogObject.twitterPlayerWidth,\n    ogObject.twitterPlayerHeight,\n    ogObject.twitterPlayerStream\n  )\n    .map(mediaMapperTwitterPlayer)\n    .sort(mediaSorter)\n\n  // Delete temporary fields\n  fieldsArray\n    .filter(function(item) {\n      return item.multiple\n    })\n    .forEach(function(item) {\n      delete ogObject[item.fieldName]\n    })\n\n  // Select the best image\n  if (ogImages.length) {\n    if (options.allMedia) {\n      ogObject.ogImage = ogImages\n    } else {\n      ogObject.ogImage = ogImages[0]\n    }\n  }\n\n  // Select the best video\n  if (ogVideos.length) {\n    if (options.allMedia) {\n      ogObject.ogVideo = ogVideos\n    } else {\n      ogObject.ogVideo = ogVideos[0]\n    }\n  }\n\n  // Select the best twitter image\n  if (twitterImages.length) {\n    if (options.allMedia) {\n      ogObject.twitterImage = twitterImages\n    } else {\n      ogObject.twitterImage = twitterImages[0]\n    }\n  }\n\n  // Select the best player\n  if (twitterPlayers.length) {\n    if (options.allMedia) {\n      ogObject.twitterPlayer = twitterPlayers\n    } else {\n      ogObject.twitterPlayer = twitterPlayers[0]\n    }\n  }\n\n  // Check for 'only get open graph info'\n  if (!options.onlyGetOpenGraphInfo) {\n    // Get title tag if og title was not provided\n    if (!ogObject.ogTitle && $('head > title').text() && $('head > title').text().length > 0) {\n      ogObject.ogTitle = $('head > title').text()\n    }\n    // Get meta description tag if og description was not provided\n    if (\n      !ogObject.ogDescription &&\n      $('head > meta[name=\"description\"]').attr('content') &&\n      $('head > meta[name=\"description\"]').attr('content').length > 0\n    ) {\n      ogObject.ogDescription = $('head > meta[name=\"description\"]').attr('content')\n    }\n    // Get first image as og:image if there is no og:image tag.\n    if (!ogObject.ogImage && ogImageFallback) {\n      var supportedImageExts = ['jpg', 'jpeg', 'png']\n      $('img').each(function(i, elem) {\n        if (\n          $(elem).attr('src') &&\n          $(elem).attr('src').length > 0 &&\n          supportedImageExts.indexOf(\n            $(elem)\n              .attr('src')\n              .split('.')\n              .pop()\n          ) !== -1\n        ) {\n          ogObject.ogImage = {\n            url: $(elem).attr('src')\n          }\n          return false\n        }\n      })\n    }\n  }\n\n  return ogObject\n}\n","import { isUrl } from 'utils/url';\nimport { parse } from './og';\nimport { mergeMetadata } from '../utils';\n/** Bad video types to not use. */\nconst BAD_VIDEO_TYPES = new Set(['application/x-shockwave-flash']);\n/** Disable using opengraph videos on specific websites. */\nconst IGNORE_VIDEO_HOSTNAMES = new Set([\n    'www.netflix.com' // ignore series trailer\n]);\nfunction buildHTMLMetadata(url, body) {\n    const og = parse(body, {});\n    console.log('og', og);\n    const { ogTitle: title, ogImage: image, ogDescription: description } = og;\n    const thumbnails = image\n        ? {\n            [0 /* Default */]: image.url\n        }\n        : undefined;\n    const meta = {\n        url: url.href,\n        title,\n        thumbnails,\n        description\n    };\n    let useVideo = !IGNORE_VIDEO_HOSTNAMES.has(url.hostname);\n    if (useVideo && og.ogVideo) {\n        const type = og.ogVideo.type;\n        const videoUrl = og.ogVideo.url;\n        const hasValidType = type ? !BAD_VIDEO_TYPES.has(type) : true;\n        useVideo = hasValidType && videoUrl && isUrl(videoUrl);\n        if (useVideo)\n            meta.url = videoUrl;\n        if (og.ogVideo.duration)\n            meta.duration = og.ogVideo.duration * 1000;\n    }\n    return meta;\n}\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { url } = ctx.req;\n        const { $, body } = ctx.state;\n        if ($ && body) {\n            const meta = buildHTMLMetadata(url, body);\n            mergeMetadata(ctx.res, meta);\n        }\n        return next();\n    }\n};\nexport default mware;\n","import { load } from 'cheerio';\nimport { fetchText } from 'utils/http';\nimport { MEDIA_USER_AGENT } from 'constants/http';\nimport { mergeMetadata } from '../utils';\nconst WORDPRESS_OEMBED_PATH = /\\/wp-json\\/oembed\\/.*?\\/embed/i;\nasync function fetchOEmbed(url) {\n    const [json] = await fetchText(url, {\n        headers: {\n            'user-agent': MEDIA_USER_AGENT\n        }\n    });\n    return json;\n}\nfunction parseOembedUrl(json) {\n    if (typeof json.html === 'string') {\n        // Decode html entities if needed\n        const html = json.html.startsWith('&lt;') ? load(json.html)('body').text() : json.html;\n        const $ = load(html);\n        let src = $('iframe').attr('src');\n        if (src) {\n            return src.startsWith('//') ? `https:${src}` : src;\n        }\n    }\n}\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        if (typeof ctx.state.oEmbed === 'boolean' && !ctx.state.oEmbed) {\n            return next();\n        }\n        const { url } = ctx.req;\n        let json;\n        if (ctx.state.oEmbedJson) {\n            json = ctx.state.oEmbedJson;\n        }\n        else if (ctx.state.$) {\n            const { $ } = ctx.state;\n            const link = $(`link[type='text/json+oembed'], link[type='application/json+oembed']`).attr('href');\n            if (link &&\n                // Wordpress embeds are super generic\n                !WORDPRESS_OEMBED_PATH.test(link)) {\n                json = await fetchOEmbed(link);\n            }\n        }\n        if (json) {\n            console.info('oembed', json);\n            const src = parseOembedUrl(json);\n            const meta = {\n                url: src,\n                description: json.description\n            };\n            mergeMetadata(ctx.res, meta);\n        }\n        return next();\n    }\n};\nexport default mware;\n","import { parse, format } from 'url';\nimport { encodeQueryParams } from 'utils/url';\nconst setQueryTrue = (prop, query) => {\n    if (!!query[prop]) {\n        query[prop] = 'true';\n        return true;\n    }\n};\n/** Set autoplay query param to true */\nconst setAutoplay = (url) => {\n    const urlObj = parse(url, true);\n    const { query } = urlObj;\n    if (!(setQueryTrue('autoplay', query) || setQueryTrue('auto_play', query))) {\n        ;\n        ['autoplay', 'auto_play'].forEach(prop => {\n            query[prop] = 'true';\n        });\n    }\n    urlObj.search = encodeQueryParams(query);\n    return format(urlObj);\n};\nconst mware = {\n    match({ protocol, host }) {\n        // BUG: server returns Access Denied\n        if (host && host.indexOf('redd.it') > -1) {\n            return false;\n        }\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { url } = ctx.res;\n        // TODO: use mime-type instead of extension\n        // need a way to compose httpHead/media mware after microdata changes url\n        const isMedia = url ? url.endsWith('mp4') : false;\n        if (!isMedia) {\n            ctx.res.url = setAutoplay(url);\n        }\n        return next();\n    }\n};\nexport default mware;\n","import { load } from 'cheerio';\nimport { parse, toSeconds } from 'iso8601-duration';\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { url } = ctx.req;\n        const { $ } = ctx.state;\n        // TODO: clean this up and make it more robust\n        if ($) {\n            const noscript = $(`noscript`);\n            noscript.each(function (idx, elem) {\n                const node = ctx.state.$(elem);\n                const text = node.text();\n                if (text.indexOf('schema.org') === -1) {\n                    return;\n                }\n                const $ = load(text);\n                const metaDuration = $(`meta[itemprop='duration']`).attr('content');\n                if (metaDuration) {\n                    const duration = toSeconds(parse(metaDuration)) * 1000;\n                    if (duration && !isNaN(duration)) {\n                        ctx.res.duration = duration;\n                    }\n                }\n            });\n        }\n        return next();\n    }\n};\nexport default mware;\n","const mware = {\n    match(url) {\n        const { hostname = '' } = url;\n        return hostname.endsWith('imgur.com');\n    },\n    async resolve(ctx, next) {\n        const { $ } = ctx.state;\n        if ($) {\n            const title = $('title')\n                .text()\n                .trim();\n            const imageSrc = $('link[rel=image_src]').attr('href');\n            const isAlbum = title.endsWith('Album on Imgur');\n            if (!isAlbum && imageSrc) {\n                await next();\n                ctx.res.url = imageSrc;\n                return ctx.res;\n            }\n        }\n        return next();\n    }\n};\nexport default mware;\n","export class MediaRequestError extends Error {\n    constructor(code) {\n        super(`Media Request Error (${code})`);\n        this.code = code;\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, MediaRequestError.prototype);\n    }\n}\n","import { MediaRequestError } from 'media/error';\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types\n */\nconst ALLOWED_CONTENT_TYPES = new Set([\n    'image/gif',\n    'text/html',\n    'image/jpeg',\n    'audio/mpeg',\n    'video/mpeg',\n    'audio/ogg',\n    'video/ogg',\n    'application/ogg',\n    'audio/opus',\n    'image/svg+xml',\n    'text/plain',\n    'audio/wav',\n    'audio/webm',\n    'video/webm',\n    'image/webp',\n    'application/xhtml+xml'\n]);\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { contentType, headResponseHeaders: headers } = ctx.state;\n        if (headers) {\n            const contentDisp = headers['content-disposition'];\n            if (typeof contentDisp === 'string' && contentDisp.startsWith('attachment')) {\n                throw new MediaRequestError(3 /* DownloadLink */);\n            }\n        }\n        // TODO: Disallow any content types known to cause download\n        // if (contentType && !ALLOWED_CONTENT_TYPES.has(contentType)) {\n        //   throw new MediaRequestError(MediaRequestErrorCode.InvalidContentType)\n        // }\n        return next();\n    }\n};\nexport default mware;\n","import { cleanObject } from 'utils/object';\nimport compose from './compose';\nimport baseMware from './middleware/base';\nimport subredditMware from './middleware/subreddit';\nimport youTubeMware from './middleware/youtube';\nimport youTubePlaylistMware from './middleware/youtube-playlist';\nimport httpHeadMware from './middleware/httpHead';\nimport mediaMware from './middleware/media';\nimport htmlMware from './middleware/html';\nimport openGraphMware from './middleware/openGraph';\nimport oEmbedMware from './middleware/oembed';\nimport autoplayMware from './middleware/autoplay';\nimport microdataMware from './middleware/microdata';\nimport imgurMware from './middleware/imgur';\nimport preventDownloadMware from './middleware/preventDownload';\n// prettier-ignore\nconst middlewares = [\n    baseMware,\n    subredditMware,\n    youTubePlaylistMware,\n    httpHeadMware,\n    preventDownloadMware,\n    mediaMware,\n    htmlMware,\n    youTubeMware,\n    imgurMware,\n    openGraphMware,\n    oEmbedMware,\n    microdataMware,\n    autoplayMware\n];\nconst createContext = (url) => {\n    const req = {\n        type: \"item\" /* Item */,\n        url,\n        // TODO: add user info for logging middleware\n        user: null\n    };\n    const res = {\n        type: \"item\" /* Item */,\n        url: url.href,\n        state: {}\n    };\n    const ctx = {\n        req,\n        res,\n        state: {}\n    };\n    return ctx;\n};\nconst finalizeMedia = (media) => {\n    if (media.description) {\n        const desc = media.description.trim();\n        media.description = desc || undefined;\n    }\n    return cleanObject(media);\n};\nexport const resolveMediaUrl = async (url) => {\n    const urlObj = new URL(url);\n    if (!urlObj.href) {\n        return null;\n    }\n    const ctx = createContext(urlObj);\n    const fn = compose(middlewares);\n    const result = (await fn(ctx)) || ctx.res;\n    console.debug('Resolved media', ctx);\n    return finalizeMedia(result);\n};\nexport const resolveMediaPlaylist = async (media) => {\n    const urlObj = new URL(media.url);\n    if (!urlObj.href) {\n        return null;\n    }\n    const ctx = createContext(urlObj);\n    // Transfer old state to new request\n    ctx.req = {\n        ...ctx.req,\n        type: media.type,\n        state: media.state\n    };\n    console.log('resolving playlist', ctx);\n    const fn = compose(middlewares);\n    const result = (await fn(ctx)) || ctx.res;\n    return finalizeMedia(result);\n};\n"],"sourceRoot":""}