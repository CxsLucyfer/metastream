{"version":3,"sources":["webpack:///./src/media/compose.ts","webpack:///./src/media/middleware/base.ts","webpack:///./src/utils/http.ts","webpack:///./src/media/middleware/subreddit.ts","webpack:///./src/media/middleware/youtube.ts","webpack:///./src/media/middleware/youtube-playlist.ts","webpack:///./src/media/middleware/httpHead.ts","webpack:///./src/media/middleware/media.ts","webpack:///./src/media/middleware/html.ts","webpack:///./src/media/middleware/og.js","webpack:///./src/media/middleware/openGraph.ts","webpack:///./src/media/middleware/oembed.ts","webpack:///./src/media/middleware/autoplay.ts","webpack:///./src/media/middleware/microdata.ts","webpack:///./src/media/middleware/imgur.ts","webpack:///./src/media/error.ts","webpack:///./src/media/middleware/preventDownload.ts","webpack:///./src/media/index.ts"],"names":["media_compose","middleware","Array","isArray","TypeError","mware","match","resolve","ctx","index","dispatch","i","Promise","reject","Error","req","url","err","base","origin","location","[object Object]","next","transformList","Set","prefixHeaders","headers","Object","keys","forEach","name","has","toLowerCase","fetchId","mainFetch","options","startsWith","URL","e","credentials","requestId","handler","event","data","type","window","removeEventListener","resp","payload","addEventListener","postMessage","fetchText","async","body","URL_PATTERN","transformPost","result","id","title","subreddit","xpost","crosspost_parent_list","media","length","parent","getListing","after","urlobj","url_url","paramObj","query","limit","params","utils_url","apiUrl","protocol","hostname","pathname","json","Referer","http","getNextPosts","children","filter","post","stickied","map","isSubreddit","exec","href","isCommentThread","includes","state","reddit","reqState","redditUrl","currentIdx","idx","console","log","error","debug","posts","child","res","hasMore","item","reddit_video","v","duration","oembed","parseItem","youtube_URL_PATTERN","VIDEO_ID_PATTERNS","YouTubeClient","this","instance","youtube","getInstance","getVideoId","metadata","$","isoDuration","attr","metaBroadcast","metaBroadcastEndDate","utils","undefined","metaDescription","description","searchParams","getScrapedMetadata","message","referrer","oEmbed","youtube_playlist_URL_PATTERN","youtube_playlist","isYouTube","isPlaylist","Boolean","ytpl","text","trim","rawLen","split","len","parseInt","isNaN","embedUrl","delete","rawIndex","get","set","toString","httpHead","response","fetchResponse","method","user-agent","referer","httpHeadFailed","code","status","server","contentType","val","shift","getContentTypeToken","getTypeToken","responseCode","disableGooglebot","MIME_MEDIA_TYPES","middleware_media","meta","path_browserify","buildMediaMetadata","middleware_html","host","cheerio","fieldsArray","multiple","property","fieldName","mediaMapperTwitterImage","width","height","alt","mediaMapperTwitterPlayer","stream","mediaMapper","str","parseFloat","mediaSorter","a","b","aRes","aExt","bRes","bExt","Math","max","BAD_VIDEO_TYPES","IGNORE_VIDEO_HOSTNAMES","buildHTMLMetadata","og","ogImageFallback","ogObject","key","attribs","content","push","ogImage","ogImageSecureURL","ogImageURL","ogImageWidth","twitterImageHeight","ogImageType","ogImageHeight","ogImages","zip","sort","ogVideo","ogVideoWidth","ogVideoHeight","ogVideoType","ogVideoDuration","ogVideoSecureURL","videoDuration","ogVideos","twitterImageSrc","twitterImage","twitterImageWidth","twitterImageAlt","twitterImages","twitterPlayer","twitterPlayerWidth","twitterPlayerHeight","twitterPlayerStream","twitterPlayers","allMedia","onlyGetOpenGraphInfo","ogTitle","ogDescription","supportedImageExts","each","elem","indexOf","pop","parse","image","thumbnails","0","useVideo","videoUrl","openGraph","WORDPRESS_OEMBED_PATH","oEmbedJson","link","test","fetchOEmbed","info","html","src","parseOembedUrl","setQueryTrue","prop","autoplay","endsWith","urlObj","search","setAutoplay","microdata","metaDuration","lib","imgur","imageSrc","MediaRequestError","super","setPrototypeOf","prototype","preventDownload","headResponseHeaders","contentDisp","__webpack_require__","d","__webpack_exports__","resolveMediaUrl","resolveMediaPlaylist","middlewares","createContext","user","finalizeMedia","desc","object","fn"],"mappings":"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","file":"3.app.prod.js","sourcesContent":["/**\n * Compose `middleware` returning\n * a fully valid middleware comprised\n * of all those which are passed.\n *\n * @param {Array} middleware\n * @return {Function}\n * @api public\n */\nfunction compose(middleware) {\n    if (!Array.isArray(middleware))\n        throw new TypeError('Middleware stack must be an array!');\n    for (const mware of middleware) {\n        if (typeof mware.match !== 'function' || typeof mware.resolve !== 'function') {\n            throw new TypeError('Middleware must be composed of functions!');\n        }\n    }\n    /**\n     * @param {Object} context\n     * @return {Promise}\n     * @api public\n     */\n    return function (ctx) {\n        // last called middleware #\n        let index = -1;\n        return dispatch(0);\n        function dispatch(i) {\n            if (i <= index)\n                return Promise.reject(new Error('next() called multiple times'));\n            index = i;\n            let mware = middleware[i];\n            if (!mware)\n                return Promise.resolve();\n            if (!mware.match(ctx.req.url, ctx)) {\n                return Promise.resolve(dispatch(i + 1));\n            }\n            try {\n                return Promise.resolve(mware.resolve(ctx, function next() {\n                    return dispatch(i + 1);\n                }));\n            }\n            catch (err) {\n                return Promise.reject(err);\n            }\n        }\n    };\n}\nexport default compose;\n","const mware = {\n    match({ origin }) {\n        return origin === location.origin;\n    },\n    resolve(ctx, next) {\n        throw new Error('Unable to request Metastream app link');\n    }\n};\nexport default mware;\n","const transformList = new Set(['user-agent', 'referer']);\nconst prefixHeaders = (headers) => {\n    if (typeof headers === 'object') {\n        headers = { ...headers };\n        // Prefix reserved headers to be fixed in the extension background script\n        Object.keys(headers).forEach(name => {\n            if (transformList.has(name.toLowerCase())) {\n                headers[`X-Metastream-${name}`] = headers[name];\n            }\n        });\n    }\n    return headers;\n};\nlet fetchId = 0;\nconst mainFetch = (url, options = {}) => {\n    return new Promise((resolve, reject) => {\n        if (url.startsWith('//')) {\n            url = `https:${url}`;\n        }\n        try {\n            new URL(url);\n        }\n        catch (e) {\n            reject(e);\n            return;\n        }\n        options = {\n            credentials: 'omit',\n            ...options,\n            headers: prefixHeaders(options.headers)\n        };\n        const requestId = fetchId++;\n        const handler = (event) => {\n            const { data } = event;\n            if (typeof data !== 'object')\n                return;\n            if (data.type !== `metastream-fetch-response${requestId}`)\n                return;\n            window.removeEventListener('message', handler, false);\n            const { err, resp } = data.payload;\n            if (err) {\n                reject(err);\n                return;\n            }\n            resolve(resp);\n        };\n        window.addEventListener('message', handler, false);\n        window.postMessage({ type: 'metastream-fetch', payload: { requestId, url, options } }, location.origin);\n    });\n};\nexport const fetchText = async (url, options) => {\n    const resp = await mainFetch(url, options);\n    return [resp.body, resp];\n};\nexport const fetchResponse = async (url, options) => {\n    const resp = await mainFetch(url, options);\n    return resp;\n};\n","import { parse } from 'url';\nimport { encodeQueryParams } from 'utils/url';\nimport { fetchText } from 'utils/http';\nimport { MEDIA_REFERRER } from 'constants/http';\nconst URL_PATTERN = /reddit\\.com\\/r\\/([^\\s/]+)\\/?/i;\nconst API_LIMIT = 5;\nconst transformPost = ({ data }) => {\n    let result = {\n        id: data.id,\n        url: data.url,\n        title: `${data.title} - /r/${data.subreddit}`\n    };\n    const xpost = data.crosspost_parent_list;\n    // TODO: secure_media_embed\n    if (data.media) {\n        result.media = data.media;\n    }\n    if (xpost && xpost.length > 0) {\n        const parent = xpost[0];\n        if (parent.url) {\n            result.url = parent.url;\n        }\n        if (parent.media) {\n            result.media = parent.media;\n        }\n    }\n    return result;\n};\nconst getListing = async (url, after) => {\n    const urlobj = parse(url, true);\n    const paramObj = {\n        ...urlobj.query,\n        limit: API_LIMIT\n    };\n    if (after) {\n        paramObj.after = after;\n    }\n    const params = encodeQueryParams(paramObj);\n    // TODO: Keep GET params for filtering\n    // TODO: Pick up from previous playlist state\n    const apiUrl = `${urlobj.protocol}//${urlobj.hostname}${urlobj.pathname}.json?${params}`;\n    const [json] = await fetchText(apiUrl, {\n        headers: {\n            Referer: MEDIA_REFERRER\n        }\n    });\n    return json;\n};\nconst getNextPosts = (json) => {\n    const posts = json.data.children.filter(post => !post.data.stickied).map(transformPost);\n    return posts;\n};\nconst parseItem = (ctx, item) => {\n    ctx.res.title = item.title;\n    // Overwrite request url with subreddit post\n    const url = new URL(item.url);\n    if (url && url.href) {\n        ctx.req.url = url;\n    }\n    const { media } = item;\n    if (media) {\n        if (media.reddit_video) {\n            const v = media.reddit_video;\n            if (url && url.href)\n                ctx.res.url = url.href;\n            const duration = v.duration * 1000;\n            if (duration)\n                ctx.res.duration = duration;\n            return true;\n        }\n        else if (media.oembed) {\n            // Defer parse to oembed middleware\n            // ctx.state.oEmbedJson = media.oembed\n            return false;\n        }\n    }\n    return false;\n};\nconst mware = {\n    match(url, ctx) {\n        const isSubreddit = !!URL_PATTERN.exec(url.href);\n        const isCommentThread = url.pathname ? url.pathname.includes('/comments/') : false;\n        return (isSubreddit && !isCommentThread) || !!(ctx.req.state && ctx.req.state.reddit);\n    },\n    async resolve(ctx, next) {\n        const reqState = ctx.req.state;\n        let redditUrl;\n        let children;\n        let after;\n        let currentIdx;\n        // TODO: filter for API listings (/hot, /new, etc.)\n        // https://www.reddit.com/dev/api/#section_listings\n        if (reqState && reqState.reddit) {\n            redditUrl = reqState.reddit.href;\n            children = reqState.reddit.children;\n            after = reqState.reddit.after;\n            currentIdx = reqState.reddit.idx;\n        }\n        else {\n            redditUrl = ctx.req.url.href;\n            const json = await getListing(redditUrl);\n            console.log('Subreddit JSON', json);\n            if (json.error) {\n                console.debug('Error fetching subreddit posts');\n                return next();\n            }\n            const posts = getNextPosts(json);\n            if (posts.length === 0) {\n                return next();\n            }\n            children = posts;\n            after = json.data.after;\n            currentIdx = -1;\n        }\n        let idx = currentIdx + 1;\n        let child = children[idx];\n        if (!child) {\n            const json = await getListing(reqState.reddit.href, reqState.reddit.after);\n            const posts = getNextPosts(json);\n            if (posts.length === 0) {\n                return next();\n            }\n            idx = 0;\n            children = posts;\n            child = children[idx];\n            after = json.data.after;\n            if (!child) {\n                return;\n            }\n        }\n        // Save pagination info for resolving next playlist item\n        ctx.res.type = \"playlist\" /* Playlist */;\n        ctx.res.hasMore = true;\n        ctx.res.state = {\n            ...ctx.res.state,\n            reddit: {\n                ...(reqState || {}).reddit,\n                href: redditUrl,\n                idx,\n                children,\n                after\n            }\n        };\n        if (!parseItem(ctx, child)) {\n            await next();\n            let title = child.title || ctx.res.title;\n            ctx.res.title = title;\n            return ctx.res;\n        }\n    }\n};\nexport default mware;\n","import { mergeMetadata, parseHtmlDescription, parseISO8601 } from '../utils';\nconst URL_PATTERN = /youtu\\.?be(?:.com)?/i;\n// TODO: https://www.youtube.com/attribution_link?a=ShEHdkiTDq4&u=%2Fwatch%3Fv%3Dm-6zjXLPRHg%26feature%3Dshare\nconst VIDEO_ID_PATTERNS = [\n    /youtu\\.be\\/([^#\\&\\?]{11})/,\n    /\\?v=([^#\\&\\?]{11})/,\n    /\\&v=([^#\\&\\?]{11})/,\n    /embed\\/([^#\\&\\?]{11})/,\n    /\\/v\\/([^#\\&\\?]{11})/ // /v/<id>\n];\nclass YouTubeClient {\n    static getInstance() {\n        if (!this.instance) {\n            this.instance = new YouTubeClient();\n        }\n        return this.instance;\n    }\n    getVideoId(url) {\n        let match;\n        for (let i = 0; i < VIDEO_ID_PATTERNS.length; i++) {\n            match = VIDEO_ID_PATTERNS[i].exec(url);\n            if (match) {\n                break;\n            }\n        }\n        return match ? match[1] : null;\n    }\n}\nasync function getScrapedMetadata(url, $) {\n    const metaDuration = $('meta[itemprop=duration]');\n    const isoDuration = metaDuration.attr('content');\n    const metaBroadcast = $('meta[itemprop=isLiveBroadcast]');\n    const metaBroadcastEndDate = $('meta[itemprop=endDate]');\n    const isLiveBroadcast = (metaBroadcast.attr('content') || '').toLowerCase() === 'true' && !metaBroadcastEndDate;\n    let duration;\n    if (isLiveBroadcast) {\n        duration = 0;\n    }\n    else {\n        duration = isoDuration ? parseISO8601(isoDuration) * 1000 : undefined;\n    }\n    const metaDescription = $('#eow-description');\n    const description = metaDescription.length === 1 ? parseHtmlDescription(metaDescription) : undefined;\n    if (url.searchParams.has('t')) {\n        // TODO: parse '1h2m3s' format\n        // startTime = parseHms(query.t)\n    }\n    return {\n        duration,\n        description\n    };\n}\nconst mware = {\n    match(url) {\n        const { hostname = '', href = '' } = url;\n        return !!URL_PATTERN.exec(hostname) && !!YouTubeClient.getInstance().getVideoId(href);\n    },\n    async resolve(ctx, next) {\n        let metadata;\n        try {\n            metadata = await getScrapedMetadata(ctx.req.url, ctx.state.$);\n        }\n        catch (e) {\n            console.error('YouTube request failed', e.message);\n            return next();\n        }\n        mergeMetadata(ctx.res, metadata);\n        // Bypass restricted embed playback\n        ctx.res.state.referrer = true;\n        // Disable oEmbed for playlists\n        ctx.state.oEmbed = false;\n        return next();\n    }\n};\nexport default mware;\n","const URL_PATTERN = /youtu\\.?be(?:.com)?/i;\nconst mware = {\n    match(url, ctx) {\n        const isYouTube = !!URL_PATTERN.exec(url.href);\n        const isPlaylist = url.searchParams.has('list');\n        return (isYouTube && isPlaylist) || Boolean(ctx.req.state && ctx.req.state.ytpl);\n    },\n    async resolve(ctx, next) {\n        const { state } = ctx.req;\n        const ytpl = (state && state.ytpl) || {};\n        const isInitialRequest = typeof ytpl.index === 'undefined';\n        if (isInitialRequest) {\n            await next();\n            const { res } = ctx;\n            const { body, $ } = ctx.state;\n            if (!body || !$)\n                return;\n            const title = $('.playlist-title').text() || res.title;\n            ytpl.title = (title || 'YouTube Playlist').trim();\n            const rawLen = $('#playlist-length')\n                .text()\n                .split(' ')[0];\n            const len = parseInt(rawLen, 10);\n            if (isNaN(len)) {\n                // private playlist\n                // try to remove playlist params from embed\n                try {\n                    const embedUrl = new URL(ctx.res.url);\n                    embedUrl.searchParams.delete('list');\n                    ctx.res.url = embedUrl.href;\n                }\n                catch { }\n                return ctx.res;\n            }\n            ytpl.length = len;\n            const rawIndex = $('li.currently-playing').data('index');\n            const params = ctx.req.url.searchParams;\n            const index = rawIndex || params.get('index') || '0';\n            ytpl.index = parseInt(index, 10) || 0;\n            ctx.res.state.ytpl = ytpl;\n        }\n        else {\n            ytpl.index++;\n            const url = ctx.req.url;\n            url.pathname = '/embed/videoseries';\n            url.searchParams.set('index', `${ytpl.index}`);\n            ctx.res.url = url.toString();\n        }\n        let { index, length, title } = ytpl;\n        ctx.res.title = title;\n        ctx.res.state = { ...ctx.req.state, ytpl, referrer: true };\n        ctx.res.hasMore = index < length - 1;\n        return ctx.res;\n    }\n};\nexport default mware;\n","import { fetchResponse } from 'utils/http';\nimport { MEDIA_USER_AGENT } from 'constants/http';\nconst getContentTypeToken = (val) => {\n    val = Array.isArray(val) ? val[0] : val;\n    val = (val && val.split(';').shift()) || '';\n    return val.trim();\n};\n/** https://www.w3.org/Protocols/rfc1341/4_Content-Type.html */\nconst getTypeToken = (val) => (val ? (val.split('/').shift() || '').toLowerCase() : '');\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { url } = ctx.req;\n        // Request HEAD response to check MIME type\n        let response;\n        try {\n            response = await fetchResponse(url.href, {\n                method: 'HEAD',\n                headers: {\n                    'user-agent': MEDIA_USER_AGENT,\n                    referer: url.href // prevent hotlink blocking\n                }\n            });\n        }\n        catch {\n            ctx.state.httpHeadFailed = true;\n            return next();\n        }\n        const code = response.status || 200;\n        const server = response.headers['server'];\n        const contentType = getContentTypeToken(response.headers['content-type']);\n        const type = getTypeToken(contentType);\n        ctx.state.responseCode = code;\n        ctx.state.contentType = contentType;\n        ctx.state.type = type;\n        // #244: Cloudflare validates agents using the Googlebot UA\n        ctx.state.disableGooglebot = server === 'cloudflare';\n        return next();\n    }\n};\nexport default mware;\n","import { basename } from 'path';\nconst MIME_MEDIA_TYPES = new Set(['audio', 'image', 'video']);\nfunction buildMediaMetadata(url) {\n    // TODO: get ID3 metadata from MP3s\n    return {\n        url: url.href,\n        title: basename(url.pathname || url.href)\n    };\n}\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    resolve({ req, res, state }, next) {\n        const { url } = req;\n        const { type } = state;\n        // Avoid GET requests to media\n        if (type && MIME_MEDIA_TYPES.has(type)) {\n            const meta = buildMediaMetadata(url);\n            res.url = meta.url || res.url;\n            res.title = res.title || meta.title;\n            return res;\n        }\n        return next();\n    }\n};\nexport default mware;\n","import { load } from 'cheerio';\nimport { fetchText } from 'utils/http';\nimport { MEDIA_USER_AGENT } from 'constants/http';\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { url } = ctx.req;\n        // Skip if HEAD request fails to avoid fetching huge blobs of data\n        if (ctx.state.httpHeadFailed) {\n            return next();\n        }\n        let text;\n        try {\n            const result = await fetchText(url.href, {\n                headers: ctx.state.disableGooglebot\n                    ? {}\n                    : {\n                        'user-agent': MEDIA_USER_AGENT,\n                        host: url.host\n                    }\n            });\n            text = result[0];\n        }\n        catch {\n            return next();\n        }\n        ctx.state.body = text;\n        const $ = (ctx.state.$ = load(text));\n        // prettier-ignore\n        ctx.res.title = $('title').text().trim() || ctx.res.title;\n        return next();\n    }\n};\nexport default mware;\n","import { load } from 'cheerio'\nimport { zip } from 'lodash-es'\n\nconst fieldsArray = [\n  {\n    multiple: false,\n    property: 'og:title',\n    fieldName: 'ogTitle'\n  },\n  {\n    multiple: false,\n    property: 'og:type',\n    fieldName: 'ogType'\n  },\n  {\n    multiple: true,\n    property: 'og:image',\n    fieldName: 'ogImage'\n  },\n  {\n    multiple: true,\n    property: 'og:image:url',\n    fieldName: 'ogImageURL'\n  },\n  {\n    multiple: true,\n    property: 'og:image:secure_url',\n    fieldName: 'ogImageSecureURL'\n  },\n  {\n    multiple: true,\n    property: 'og:image:width',\n    fieldName: 'ogImageWidth'\n  },\n  {\n    multiple: true,\n    property: 'og:image:height',\n    fieldName: 'ogImageHeight'\n  },\n  {\n    multiple: true,\n    property: 'og:image:type',\n    fieldName: 'ogImageType'\n  },\n  {\n    multiple: false,\n    property: 'og:url',\n    fieldName: 'ogUrl'\n  },\n  {\n    multiple: false,\n    property: 'og:audio',\n    fieldName: 'ogAudio'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:url',\n    fieldName: 'ogAudioURL'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:secure_url',\n    fieldName: 'ogAudioSecureURL'\n  },\n  {\n    multiple: false,\n    property: 'og:audio:type',\n    fieldName: 'ogAudioType'\n  },\n  {\n    multiple: false,\n    property: 'og:description',\n    fieldName: 'ogDescription'\n  },\n  {\n    multiple: false,\n    property: 'og:determiner',\n    fieldName: 'ogDeterminer'\n  },\n  {\n    multiple: false,\n    property: 'og:locale',\n    fieldName: 'ogLocale'\n  },\n  {\n    multiple: false,\n    property: 'og:locale:alternate',\n    fieldName: 'ogLocaleAlternate'\n  },\n  {\n    multiple: false,\n    property: 'og:site_name',\n    fieldName: 'ogSiteName'\n  },\n  {\n    multiple: true,\n    property: 'og:video',\n    fieldName: 'ogVideo'\n  },\n  {\n    multiple: true,\n    property: 'og:video:url', // An alternative to 'og:video'\n    fieldName: 'ogVideo'\n  },\n  {\n    multiple: true,\n    property: 'og:video:secure_url',\n    fieldName: 'ogVideoSecureURL'\n  },\n  {\n    multiple: true,\n    property: 'og:video:width',\n    fieldName: 'ogVideoWidth'\n  },\n  {\n    multiple: true,\n    property: 'og:video:height',\n    fieldName: 'ogVideoHeight'\n  },\n  {\n    multiple: true,\n    property: 'og:video:type',\n    fieldName: 'ogVideoType'\n  },\n  // This format is wrong, but was seen on vk.com\n  {\n    multiple: true,\n    property: 'og:video:duration',\n    fieldName: 'ogVideoDuration'\n  },\n  {\n    multiple: true,\n    property: 'video:duration',\n    fieldName: 'videoDuration'\n  },\n  {\n    multiple: false,\n    property: 'twitter:card',\n    fieldName: 'twitterCard'\n  },\n  {\n    multiple: false,\n    property: 'twitter:site',\n    fieldName: 'twitterSite'\n  },\n  {\n    multiple: false,\n    property: 'twitter:site:id',\n    fieldName: 'twitterSiteId'\n  },\n  {\n    multiple: false,\n    property: 'twitter:creator',\n    fieldName: 'twitterCreator'\n  },\n  {\n    multiple: false,\n    property: 'twitter:creator:id',\n    fieldName: 'twitterCreatorId'\n  },\n  {\n    multiple: false,\n    property: 'twitter:title',\n    fieldName: 'twitterTitle'\n  },\n  {\n    multiple: false,\n    property: 'twitter:description',\n    fieldName: 'twitterDescription'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image',\n    fieldName: 'twitterImage'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:height',\n    fieldName: 'twitterImageHeight'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:width',\n    fieldName: 'twitterImageWidth'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:src',\n    fieldName: 'twitterImageSrc'\n  },\n  {\n    multiple: true,\n    property: 'twitter:image:alt',\n    fieldName: 'twitterImageAlt'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player',\n    fieldName: 'twitterPlayer'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:width',\n    fieldName: 'twitterPlayerWidth'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:height',\n    fieldName: 'twitterPlayerHeight'\n  },\n  {\n    multiple: true,\n    property: 'twitter:player:stream',\n    fieldName: 'twitterPlayerStream'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:iphone',\n    fieldName: 'twitterAppNameiPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:iphone',\n    fieldName: 'twitterAppIdiPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:iphone',\n    fieldName: 'twitterAppUrliPhone'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:ipad',\n    fieldName: 'twitterAppNameiPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:ipad',\n    fieldName: 'twitterAppIdiPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:ipad',\n    fieldName: 'twitterAppUrliPad'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:name:googleplay',\n    fieldName: 'twitterAppNameGooglePlay'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:id:googleplay',\n    fieldName: 'twitterAppIdGooglePlay'\n  },\n  {\n    multiple: false,\n    property: 'twitter:app:url:googleplay',\n    fieldName: 'twitterAppUrlGooglePlay'\n  }\n]\n\nvar parseNumbers = function(str) {\n  if (!isNaN(str)) {\n    str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str)\n  }\n  return str\n}\n\nvar mediaMapperTwitterImage = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    alt: item[3]\n  }\n}\n\nvar mediaMapperTwitterPlayer = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    stream: item[3]\n  }\n}\n\nvar mediaMapper = function(item) {\n  return {\n    url: item[0],\n    width: item[1],\n    height: item[2],\n    type: item[3],\n    duration: parseNumbers(item[4])\n  }\n}\n\nvar mediaSorter = function(a, b) {\n  if (!(a.url && b.url)) {\n    return 0\n  }\n\n  var aRes = a.url.match(/\\.(\\w{2,5})$/),\n    aExt = (aRes && aRes[1].toLowerCase()) || null\n  var bRes = b.url.match(/\\.(\\w{2,5})$/),\n    bExt = (bRes && bRes[1].toLowerCase()) || null\n\n  if (aExt === 'gif' && bExt !== 'gif') {\n    return -1\n  } else if (aExt !== 'gif' && bExt === 'gif') {\n    return 1\n  } else {\n    return Math.max(b.width, b.height) - Math.max(a.width, a.height)\n  }\n}\n\n/*\n * getOG - scrape that url!\n * @param string url - the url we want to scrape\n * @param function callback\n */\nexport function parse(body, options) {\n  const ogImageFallback = options.ogImageFallback === undefined ? true : options.ogImageFallback\n\n  let $ = load(body),\n    meta = $('meta'),\n    keys = Object.keys(meta)\n\n  let ogObject = {}\n\n  keys.forEach(function(key) {\n    if (!(meta[key].attribs && (meta[key].attribs.property || meta[key].attribs.name))) {\n      return\n    }\n    var property = meta[key].attribs.property || meta[key].attribs.name,\n      content = meta[key].attribs.content\n    fieldsArray.forEach(function(item) {\n      if (property === item.property) {\n        if (!item.multiple) {\n          ogObject[item.fieldName] = content\n        } else if (!ogObject[item.fieldName]) {\n          ogObject[item.fieldName] = [content]\n        } else if (Array.isArray(ogObject[item.fieldName])) {\n          ogObject[item.fieldName].push(content)\n        }\n      }\n    })\n  })\n\n  // set the ogImage or fallback to ogImageURL or ogImageSecureURL\n  ogObject.ogImage = ogObject.ogImageSecureURL\n    ? ogObject.ogImageSecureURL\n    : ogObject.ogImage\n    ? ogObject.ogImage\n    : ogObject.ogImageURL\n    ? ogObject.ogImageURL\n    : []\n  if (!ogObject.ogImage || !ogObject.ogImage.length) {\n    delete ogObject['ogImage']\n  }\n\n  /* Combine image/width/height/type\n      and sort for priority */\n  if (\n    ogObject.ogImage ||\n    ogObject.ogImageWidth ||\n    ogObject.twitterImageHeight ||\n    ogObject.ogImageType\n  ) {\n    ogObject.ogImage = ogObject.ogImage ? ogObject.ogImage : [null]\n    ogObject.ogImageWidth = ogObject.ogImageWidth ? ogObject.ogImageWidth : [null]\n    ogObject.ogImageHeight = ogObject.ogImageHeight ? ogObject.ogImageHeight : [null]\n    ogObject.ogImageType = ogObject.ogImageType ? ogObject.ogImageType : [null]\n  }\n  var ogImages = zip(\n    ogObject.ogImage,\n    ogObject.ogImageWidth,\n    ogObject.ogImageHeight,\n    ogObject.ogImageType\n  )\n    .map(mediaMapper)\n    .sort(mediaSorter)\n\n  /* Combine video/width/height/type\n      and sort for priority */\n  if (\n    ogObject.ogVideo ||\n    ogObject.ogVideoWidth ||\n    ogObject.ogVideoHeight ||\n    ogObject.ogVideoType ||\n    ogObject.ogVideoDuration\n  ) {\n    ogObject.ogVideo = ogObject.ogVideo ? ogObject.ogVideo : [null]\n    ogObject.ogVideo = ogObject.ogVideoSecureURL ? ogObject.ogVideoSecureURL : ogObject.ogVideo\n    ogObject.ogVideoWidth = ogObject.ogVideoWidth ? ogObject.ogVideoWidth : [null]\n    ogObject.ogVideoHeight = ogObject.ogVideoHeight ? ogObject.ogVideoHeight : [null]\n    ogObject.ogVideoType = ogObject.ogVideoType ? ogObject.ogVideoType : [null]\n    ogObject.ogVideoDuration = ogObject.videoDuration || ogObject.ogVideoDuration || [null]\n  }\n  var ogVideos = zip(\n    ogObject.ogVideo,\n    ogObject.ogVideoWidth,\n    ogObject.ogVideoHeight,\n    ogObject.ogVideoType,\n    ogObject.ogVideoDuration\n  )\n    .map(mediaMapper)\n    .sort(mediaSorter)\n\n  /* Combine twitter image/width/height/alt\n      and sort for priority */\n  if (\n    ogObject.twitterImageSrc ||\n    ogObject.twitterImage ||\n    ogObject.twitterImageWidth ||\n    ogObject.twitterImageHeight ||\n    ogObject.twitterImageAlt\n  ) {\n    ogObject.twitterImage = ogObject.twitterImage ? ogObject.twitterImage : ogObject.twitterImageSrc\n    ogObject.twitterImage = ogObject.twitterImage ? ogObject.twitterImage : [null]\n    ogObject.twitterImageWidth = ogObject.twitterImageWidth ? ogObject.twitterImageWidth : [null]\n    ogObject.twitterImageHeight = ogObject.twitterImageHeight ? ogObject.twitterImageHeight : [null]\n    ogObject.twitterImageAlt = ogObject.twitterImageAlt ? ogObject.twitterImageAlt : [null]\n  }\n  var twitterImages = zip(\n    ogObject.twitterImage,\n    ogObject.twitterImageWidth,\n    ogObject.twitterImageHeight,\n    ogObject.twitterImageAlt\n  )\n    .map(mediaMapperTwitterImage)\n    .sort(mediaSorter)\n\n  /* Combine twitter player/width/height/stream\n      and sort for priority */\n  if (\n    ogObject.twitterPlayer ||\n    ogObject.twitterPlayerWidth ||\n    ogObject.twitterPlayerHeight ||\n    ogObject.twitterPlayerStream\n  ) {\n    ogObject.twitterPlayer = ogObject.twitterPlayer ? ogObject.twitterPlayer : [null]\n    ogObject.twitterPlayerWidth = ogObject.twitterPlayerWidth ? ogObject.twitterPlayerWidth : [null]\n    ogObject.twitterPlayerHeight = ogObject.twitterPlayerHeight\n      ? ogObject.twitterPlayerHeight\n      : [null]\n    ogObject.twitterPlayerStream = ogObject.twitterPlayerStream\n      ? ogObject.twitterPlayerStream\n      : [null]\n  }\n  var twitterPlayers = zip(\n    ogObject.twitterPlayer,\n    ogObject.twitterPlayerWidth,\n    ogObject.twitterPlayerHeight,\n    ogObject.twitterPlayerStream\n  )\n    .map(mediaMapperTwitterPlayer)\n    .sort(mediaSorter)\n\n  // Delete temporary fields\n  fieldsArray\n    .filter(function(item) {\n      return item.multiple\n    })\n    .forEach(function(item) {\n      delete ogObject[item.fieldName]\n    })\n\n  // Select the best image\n  if (ogImages.length) {\n    if (options.allMedia) {\n      ogObject.ogImage = ogImages\n    } else {\n      ogObject.ogImage = ogImages[0]\n    }\n  }\n\n  // Select the best video\n  if (ogVideos.length) {\n    if (options.allMedia) {\n      ogObject.ogVideo = ogVideos\n    } else {\n      ogObject.ogVideo = ogVideos[0]\n    }\n  }\n\n  // Select the best twitter image\n  if (twitterImages.length) {\n    if (options.allMedia) {\n      ogObject.twitterImage = twitterImages\n    } else {\n      ogObject.twitterImage = twitterImages[0]\n    }\n  }\n\n  // Select the best player\n  if (twitterPlayers.length) {\n    if (options.allMedia) {\n      ogObject.twitterPlayer = twitterPlayers\n    } else {\n      ogObject.twitterPlayer = twitterPlayers[0]\n    }\n  }\n\n  // Check for 'only get open graph info'\n  if (!options.onlyGetOpenGraphInfo) {\n    // Get title tag if og title was not provided\n    if (!ogObject.ogTitle && $('head > title').text() && $('head > title').text().length > 0) {\n      ogObject.ogTitle = $('head > title').text()\n    }\n    // Get meta description tag if og description was not provided\n    if (\n      !ogObject.ogDescription &&\n      $('head > meta[name=\"description\"]').attr('content') &&\n      $('head > meta[name=\"description\"]').attr('content').length > 0\n    ) {\n      ogObject.ogDescription = $('head > meta[name=\"description\"]').attr('content')\n    }\n    // Get first image as og:image if there is no og:image tag.\n    if (!ogObject.ogImage && ogImageFallback) {\n      var supportedImageExts = ['jpg', 'jpeg', 'png']\n      $('img').each(function(i, elem) {\n        if (\n          $(elem).attr('src') &&\n          $(elem).attr('src').length > 0 &&\n          supportedImageExts.indexOf(\n            $(elem)\n              .attr('src')\n              .split('.')\n              .pop()\n          ) !== -1\n        ) {\n          ogObject.ogImage = {\n            url: $(elem).attr('src')\n          }\n          return false\n        }\n      })\n    }\n  }\n\n  return ogObject\n}\n","import { isUrl } from 'utils/url';\nimport { parse } from './og';\nimport { mergeMetadata } from '../utils';\n/** Bad video types to not use. */\nconst BAD_VIDEO_TYPES = new Set(['application/x-shockwave-flash']);\n/** Disable using opengraph videos on specific websites. */\nconst IGNORE_VIDEO_HOSTNAMES = new Set([\n    'www.netflix.com' // ignore series trailer\n]);\nfunction buildHTMLMetadata(url, body) {\n    const og = parse(body, {});\n    console.log('og', og);\n    const { ogTitle: title, ogImage: image, ogDescription: description } = og;\n    const thumbnails = image\n        ? {\n            [0 /* Default */]: image.url\n        }\n        : undefined;\n    const meta = {\n        url: url.href,\n        title,\n        thumbnails,\n        description\n    };\n    let useVideo = !IGNORE_VIDEO_HOSTNAMES.has(url.hostname);\n    if (useVideo && og.ogVideo) {\n        const type = og.ogVideo.type;\n        const videoUrl = og.ogVideo.url;\n        const hasValidType = type ? !BAD_VIDEO_TYPES.has(type) : true;\n        useVideo = hasValidType && videoUrl && isUrl(videoUrl);\n        if (useVideo)\n            meta.url = videoUrl;\n        if (og.ogVideo.duration)\n            meta.duration = og.ogVideo.duration * 1000;\n    }\n    return meta;\n}\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { url } = ctx.req;\n        const { $, body } = ctx.state;\n        if ($ && body) {\n            const meta = buildHTMLMetadata(url, body);\n            mergeMetadata(ctx.res, meta);\n        }\n        return next();\n    }\n};\nexport default mware;\n","import { load } from 'cheerio';\nimport { fetchText } from 'utils/http';\nimport { MEDIA_USER_AGENT } from 'constants/http';\nimport { mergeMetadata } from '../utils';\nconst WORDPRESS_OEMBED_PATH = /\\/wp-json\\/oembed\\/.*?\\/embed/i;\nasync function fetchOEmbed(url) {\n    const [json] = await fetchText(url, {\n        headers: {\n            'user-agent': MEDIA_USER_AGENT\n        }\n    });\n    return json;\n}\nfunction parseOembedUrl(json) {\n    if (typeof json.html === 'string') {\n        // Decode html entities if needed\n        const html = json.html.startsWith('&lt;') ? load(json.html)('body').text() : json.html;\n        const $ = load(html);\n        let src = $('iframe').attr('src');\n        if (src) {\n            return src.startsWith('//') ? `https:${src}` : src;\n        }\n    }\n}\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        if (typeof ctx.state.oEmbed === 'boolean' && !ctx.state.oEmbed) {\n            return next();\n        }\n        const { url } = ctx.req;\n        let json;\n        if (ctx.state.oEmbedJson) {\n            json = ctx.state.oEmbedJson;\n        }\n        else if (ctx.state.$) {\n            const { $ } = ctx.state;\n            const link = $(`link[type='text/json+oembed'], link[type='application/json+oembed']`).attr('href');\n            if (link &&\n                // Wordpress embeds are super generic\n                !WORDPRESS_OEMBED_PATH.test(link)) {\n                json = await fetchOEmbed(link);\n            }\n        }\n        if (json) {\n            console.info('oembed', json);\n            const src = parseOembedUrl(json);\n            const meta = {\n                url: src,\n                description: json.description\n            };\n            mergeMetadata(ctx.res, meta);\n        }\n        return next();\n    }\n};\nexport default mware;\n","import { parse, format } from 'url';\nimport { encodeQueryParams } from 'utils/url';\nconst setQueryTrue = (prop, query) => {\n    if (!!query[prop]) {\n        query[prop] = 'true';\n        return true;\n    }\n};\n/** Set autoplay query param to true */\nconst setAutoplay = (url) => {\n    const urlObj = parse(url, true);\n    const { query } = urlObj;\n    if (!(setQueryTrue('autoplay', query) || setQueryTrue('auto_play', query))) {\n        ;\n        ['autoplay', 'auto_play'].forEach(prop => {\n            query[prop] = 'true';\n        });\n    }\n    urlObj.search = encodeQueryParams(query);\n    return format(urlObj);\n};\nconst mware = {\n    match({ protocol, host }) {\n        // BUG: server returns Access Denied\n        if (host && host.indexOf('redd.it') > -1) {\n            return false;\n        }\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { url } = ctx.res;\n        // TODO: use mime-type instead of extension\n        // need a way to compose httpHead/media mware after microdata changes url\n        const isMedia = url ? url.endsWith('mp4') : false;\n        if (!isMedia) {\n            ctx.res.url = setAutoplay(url);\n        }\n        return next();\n    }\n};\nexport default mware;\n","import { load } from 'cheerio';\nimport { parse, toSeconds } from 'iso8601-duration';\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { url } = ctx.req;\n        const { $ } = ctx.state;\n        // TODO: clean this up and make it more robust\n        if ($) {\n            const noscript = $(`noscript`);\n            noscript.each(function (idx, elem) {\n                const node = ctx.state.$(elem);\n                const text = node.text();\n                if (text.indexOf('schema.org') === -1) {\n                    return;\n                }\n                const $ = load(text);\n                const metaDuration = $(`meta[itemprop='duration']`).attr('content');\n                if (metaDuration) {\n                    const duration = toSeconds(parse(metaDuration)) * 1000;\n                    if (duration && !isNaN(duration)) {\n                        ctx.res.duration = duration;\n                    }\n                }\n            });\n        }\n        return next();\n    }\n};\nexport default mware;\n","const mware = {\n    match(url) {\n        const { hostname = '' } = url;\n        return hostname.endsWith('imgur.com');\n    },\n    async resolve(ctx, next) {\n        const { $ } = ctx.state;\n        if ($) {\n            const title = $('title')\n                .text()\n                .trim();\n            const imageSrc = $('link[rel=image_src]').attr('href');\n            const isAlbum = title.endsWith('Album on Imgur');\n            if (!isAlbum && imageSrc) {\n                await next();\n                ctx.res.url = imageSrc;\n                return ctx.res;\n            }\n        }\n        return next();\n    }\n};\nexport default mware;\n","export class MediaRequestError extends Error {\n    constructor(code) {\n        super(`Media Request Error (${code})`);\n        this.code = code;\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, MediaRequestError.prototype);\n    }\n}\n","import { MediaRequestError } from 'media/error';\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types\n */\nconst ALLOWED_CONTENT_TYPES = new Set([\n    'image/gif',\n    'text/html',\n    'image/jpeg',\n    'audio/mpeg',\n    'video/mpeg',\n    'audio/ogg',\n    'video/ogg',\n    'application/ogg',\n    'audio/opus',\n    'image/svg+xml',\n    'text/plain',\n    'audio/wav',\n    'audio/webm',\n    'video/webm',\n    'image/webp',\n    'application/xhtml+xml'\n]);\nconst mware = {\n    match({ protocol }) {\n        return protocol === 'http:' || protocol === 'https:';\n    },\n    async resolve(ctx, next) {\n        const { contentType, headResponseHeaders: headers } = ctx.state;\n        if (headers) {\n            const contentDisp = headers['content-disposition'];\n            if (typeof contentDisp === 'string' && contentDisp.startsWith('attachment')) {\n                throw new MediaRequestError(3 /* DownloadLink */);\n            }\n        }\n        // TODO: Disallow any content types known to cause download\n        // if (contentType && !ALLOWED_CONTENT_TYPES.has(contentType)) {\n        //   throw new MediaRequestError(MediaRequestErrorCode.InvalidContentType)\n        // }\n        return next();\n    }\n};\nexport default mware;\n","import { cleanObject } from 'utils/object';\nimport compose from './compose';\nimport baseMware from './middleware/base';\nimport subredditMware from './middleware/subreddit';\nimport youTubeMware from './middleware/youtube';\nimport youTubePlaylistMware from './middleware/youtube-playlist';\nimport httpHeadMware from './middleware/httpHead';\nimport mediaMware from './middleware/media';\nimport htmlMware from './middleware/html';\nimport openGraphMware from './middleware/openGraph';\nimport oEmbedMware from './middleware/oembed';\nimport autoplayMware from './middleware/autoplay';\nimport microdataMware from './middleware/microdata';\nimport imgurMware from './middleware/imgur';\nimport preventDownloadMware from './middleware/preventDownload';\n// prettier-ignore\nconst middlewares = [\n    baseMware,\n    subredditMware,\n    youTubePlaylistMware,\n    httpHeadMware,\n    preventDownloadMware,\n    mediaMware,\n    htmlMware,\n    youTubeMware,\n    imgurMware,\n    openGraphMware,\n    oEmbedMware,\n    microdataMware,\n    autoplayMware\n];\nconst createContext = (url) => {\n    const req = {\n        type: \"item\" /* Item */,\n        url,\n        // TODO: add user info for logging middleware\n        user: null\n    };\n    const res = {\n        type: \"item\" /* Item */,\n        url: url.href,\n        state: {}\n    };\n    const ctx = {\n        req,\n        res,\n        state: {}\n    };\n    return ctx;\n};\nconst finalizeMedia = (media) => {\n    if (media.description) {\n        const desc = media.description.trim();\n        media.description = desc || undefined;\n    }\n    return cleanObject(media);\n};\nexport const resolveMediaUrl = async (url) => {\n    const urlObj = new URL(url);\n    if (!urlObj.href) {\n        return null;\n    }\n    const ctx = createContext(urlObj);\n    const fn = compose(middlewares);\n    const result = (await fn(ctx)) || ctx.res;\n    console.debug('Resolved media', ctx);\n    return finalizeMedia(result);\n};\nexport const resolveMediaPlaylist = async (media) => {\n    const urlObj = new URL(media.url);\n    if (!urlObj.href) {\n        return null;\n    }\n    const ctx = createContext(urlObj);\n    // Transfer old state to new request\n    ctx.req = {\n        ...ctx.req,\n        type: media.type,\n        state: media.state\n    };\n    console.log('resolving playlist', ctx);\n    const fn = compose(middlewares);\n    const result = (await fn(ctx)) || ctx.res;\n    return finalizeMedia(result);\n};\n"],"sourceRoot":""}